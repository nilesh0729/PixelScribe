// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attempts.sql

package db

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const countAttemptsByDictation = `-- name: CountAttemptsByDictation :one
SELECT COUNT(*) FROM attempts
WHERE user_id = $1 AND dictation_id = $2
`

type CountAttemptsByDictationParams struct {
	UserID      sql.NullInt64 `json:"user_id"`
	DictationID sql.NullInt64 `json:"dictation_id"`
}

func (q *Queries) CountAttemptsByDictation(ctx context.Context, arg CountAttemptsByDictationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAttemptsByDictation, arg.UserID, arg.DictationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttempts = `-- name: CreateAttempts :one
INSERT INTO attempts (
  user_id, 
  dictation_id, 
  typed_text, 
  attempt_no, 
  total_words, 
  correct_words, 
  grammatical_errors, 
  spelling_errors, 
  case_errors, 
  accuracy, 
  comparison_data, 
  time_spent,
  created_at
) VALUES (
  $1, $2, $3, 
  COALESCE((
    SELECT MAX(attempt_no) + 1
    FROM attempts
    WHERE user_id = $1 AND dictation_id = $2
  ), 1), 
  $4, $5, $6, $7, $8, $9, $10, $11, NOW()
)
RETURNING id, user_id, dictation_id, typed_text, attempt_no, total_words, correct_words, grammatical_errors, spelling_errors, case_errors, accuracy, comparison_data, time_spent, created_at
`

type CreateAttemptsParams struct {
	UserID            sql.NullInt64         `json:"user_id"`
	DictationID       sql.NullInt64         `json:"dictation_id"`
	TypedText         sql.NullString        `json:"typed_text"`
	TotalWords        sql.NullInt32         `json:"total_words"`
	CorrectWords      sql.NullInt32         `json:"correct_words"`
	GrammaticalErrors sql.NullInt32         `json:"grammatical_errors"`
	SpellingErrors    sql.NullInt32         `json:"spelling_errors"`
	CaseErrors        sql.NullInt32         `json:"case_errors"`
	Accuracy          sql.NullFloat64       `json:"accuracy"`
	ComparisonData    pqtype.NullRawMessage `json:"comparison_data"`
	TimeSpent         sql.NullFloat64       `json:"time_spent"`
}

func (q *Queries) CreateAttempts(ctx context.Context, arg CreateAttemptsParams) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, createAttempts,
		arg.UserID,
		arg.DictationID,
		arg.TypedText,
		arg.TotalWords,
		arg.CorrectWords,
		arg.GrammaticalErrors,
		arg.SpellingErrors,
		arg.CaseErrors,
		arg.Accuracy,
		arg.ComparisonData,
		arg.TimeSpent,
	)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DictationID,
		&i.TypedText,
		&i.AttemptNo,
		&i.TotalWords,
		&i.CorrectWords,
		&i.GrammaticalErrors,
		&i.SpellingErrors,
		&i.CaseErrors,
		&i.Accuracy,
		&i.ComparisonData,
		&i.TimeSpent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAttempt = `-- name: DeleteAttempt :exec
DELETE FROM attempts
WHERE id = $1
`

func (q *Queries) DeleteAttempt(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAttempt, id)
	return err
}

const deleteAttemptsByDictation = `-- name: DeleteAttemptsByDictation :exec
DELETE FROM attempts
WHERE dictation_id = $1 AND user_id = $2
`

type DeleteAttemptsByDictationParams struct {
	DictationID sql.NullInt64 `json:"dictation_id"`
	UserID      sql.NullInt64 `json:"user_id"`
}

func (q *Queries) DeleteAttemptsByDictation(ctx context.Context, arg DeleteAttemptsByDictationParams) error {
	_, err := q.db.ExecContext(ctx, deleteAttemptsByDictation, arg.DictationID, arg.UserID)
	return err
}

const getAttemptById = `-- name: GetAttemptById :one
SELECT id, user_id, dictation_id, typed_text, attempt_no, total_words, correct_words, grammatical_errors, spelling_errors, case_errors, accuracy, comparison_data, time_spent, created_at FROM attempts
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAttemptById(ctx context.Context, id int64) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, getAttemptById, id)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DictationID,
		&i.TypedText,
		&i.AttemptNo,
		&i.TotalWords,
		&i.CorrectWords,
		&i.GrammaticalErrors,
		&i.SpellingErrors,
		&i.CaseErrors,
		&i.Accuracy,
		&i.ComparisonData,
		&i.TimeSpent,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestAttempt = `-- name: GetLatestAttempt :one
SELECT id, user_id, dictation_id, typed_text, attempt_no, total_words, correct_words, grammatical_errors, spelling_errors, case_errors, accuracy, comparison_data, time_spent, created_at FROM attempts
WHERE user_id = $1 AND dictation_id = $2
ORDER BY created_at DESC
`

type GetLatestAttemptParams struct {
	UserID      sql.NullInt64 `json:"user_id"`
	DictationID sql.NullInt64 `json:"dictation_id"`
}

func (q *Queries) GetLatestAttempt(ctx context.Context, arg GetLatestAttemptParams) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, getLatestAttempt, arg.UserID, arg.DictationID)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DictationID,
		&i.TypedText,
		&i.AttemptNo,
		&i.TotalWords,
		&i.CorrectWords,
		&i.GrammaticalErrors,
		&i.SpellingErrors,
		&i.CaseErrors,
		&i.Accuracy,
		&i.ComparisonData,
		&i.TimeSpent,
		&i.CreatedAt,
	)
	return i, err
}

const listAttemptsByDictation = `-- name: ListAttemptsByDictation :many
SELECT id, user_id, dictation_id, typed_text, attempt_no, total_words, correct_words, grammatical_errors, spelling_errors, case_errors, accuracy, comparison_data, time_spent, created_at FROM attempts
WHERE dictation_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAttemptsByDictation(ctx context.Context, dictationID sql.NullInt64) ([]Attempt, error) {
	rows, err := q.db.QueryContext(ctx, listAttemptsByDictation, dictationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attempt
	for rows.Next() {
		var i Attempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DictationID,
			&i.TypedText,
			&i.AttemptNo,
			&i.TotalWords,
			&i.CorrectWords,
			&i.GrammaticalErrors,
			&i.SpellingErrors,
			&i.CaseErrors,
			&i.Accuracy,
			&i.ComparisonData,
			&i.TimeSpent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttemptsByUser = `-- name: ListAttemptsByUser :many
SELECT id, user_id, dictation_id, typed_text, attempt_no, total_words, correct_words, grammatical_errors, spelling_errors, case_errors, accuracy, comparison_data, time_spent, created_at FROM attempts
WHERE user_id = $1
ORDER by created_at DESC
`

func (q *Queries) ListAttemptsByUser(ctx context.Context, userID sql.NullInt64) ([]Attempt, error) {
	rows, err := q.db.QueryContext(ctx, listAttemptsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attempt
	for rows.Next() {
		var i Attempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DictationID,
			&i.TypedText,
			&i.AttemptNo,
			&i.TotalWords,
			&i.CorrectWords,
			&i.GrammaticalErrors,
			&i.SpellingErrors,
			&i.CaseErrors,
			&i.Accuracy,
			&i.ComparisonData,
			&i.TimeSpent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttemptAccuracy = `-- name: UpdateAttemptAccuracy :one
UPDATE attempts
SET
  accuracy = $2,
  correct_words = $3,
  grammatical_errors = $4,
  spelling_errors = $5,
  case_errors = $6,
  comparison_data = $7,
  time_spent = $8
WHERE id = $1
RETURNING id, user_id, dictation_id, typed_text, attempt_no, total_words, correct_words, grammatical_errors, spelling_errors, case_errors, accuracy, comparison_data, time_spent, created_at
`

type UpdateAttemptAccuracyParams struct {
	ID                int64                 `json:"id"`
	Accuracy          sql.NullFloat64       `json:"accuracy"`
	CorrectWords      sql.NullInt32         `json:"correct_words"`
	GrammaticalErrors sql.NullInt32         `json:"grammatical_errors"`
	SpellingErrors    sql.NullInt32         `json:"spelling_errors"`
	CaseErrors        sql.NullInt32         `json:"case_errors"`
	ComparisonData    pqtype.NullRawMessage `json:"comparison_data"`
	TimeSpent         sql.NullFloat64       `json:"time_spent"`
}

func (q *Queries) UpdateAttemptAccuracy(ctx context.Context, arg UpdateAttemptAccuracyParams) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, updateAttemptAccuracy,
		arg.ID,
		arg.Accuracy,
		arg.CorrectWords,
		arg.GrammaticalErrors,
		arg.SpellingErrors,
		arg.CaseErrors,
		arg.ComparisonData,
		arg.TimeSpent,
	)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DictationID,
		&i.TypedText,
		&i.AttemptNo,
		&i.TotalWords,
		&i.CorrectWords,
		&i.GrammaticalErrors,
		&i.SpellingErrors,
		&i.CaseErrors,
		&i.Accuracy,
		&i.ComparisonData,
		&i.TimeSpent,
		&i.CreatedAt,
	)
	return i, err
}
